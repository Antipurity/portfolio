<!DOCTYPE html>
<html>
<head>
  <title>Vue testing</title>
  <script src="https://unpkg.com/vue"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.js"></script>
</head>
<body>
  <span id="app" :title=message>
    <button v-on:click="--count">-</button>
    <animated-text :value=count></animated-text>
    <button v-on:click="++count">+</button>
    <hr>

    <input v-model=text>
    <animated-text :value=text></animated-text>
    <hr>
    <button v-on:click="items.push(text)">Add item</button>
    <button v-on:click="shuffle(items)">Shuffle items</button>
    <button v-on:click="items.splice(Math.random() * items.length | 0, 1)">Remove a random item</button>
    <hr>

    <world _class=wholeWidth>
      <hr>
      <block>.</block>
      <obj _class=rounded1>Hello <constraint name=link7></constraint> there</obj>
      <block>.</block>
      <hr>
      <obj _class=rounded1>
        <constraint name=link2></constraint>
        <transition-group name=fade tag=ul>
          <li v-for="(ch, index) in items" :key="ch+'#'">{{ch}}</li>
        </transition-group>
      </obj>
      <hr>
      <obj _class=rounded1><constraint name=link2></constraint><constraint name=link3></constraint></obj>
      <obj _class=rounded1><constraint name=link3></constraint><constraint name=link4></constraint></obj>
      <obj _class=rounded1><constraint name=link4></constraint><constraint name=link5></constraint></obj>
      <obj _class=rounded1><constraint name=link5></constraint><constraint name=link6></constraint></obj>
      <obj _class=rounded1><constraint name=link6></constraint><constraint name=link7></constraint></obj>
      <!-- <obj static _class=wholeWidth>floor is here</obj>
      <hr>
      <obj static>floor is here</obj> -->
    </world>
  </span>

  <style>
    .rounded1 {
      display: inline-block;
      background-color: lightblue;
      border-radius: 1em;
      padding: 1em;
    }
    .wholeWidth {
      display: block;
      width: 100%;
    }
    .dot {
      width: 100px; height: 1px;
      background-color: black;
      display: inline-block;
    }
  </style>

  <script>
// TODO: Extract physics into a separate file, for modularity.
// TODO: Create a website about how great I am.
// Vue-integrated physics.
Vue.component('world', {
  props:{
    _class:{ type: String, default: 'block' },
    gravityX:{ type: Number, default: 0, },
    gravityY:{ type: Number, default: 1, },
    bounded:{ type: Boolean, default: true },
    allowDragging:{ type: Boolean, default: true },
  },
  render(h) {
    this.engine.gravity.x = this.gravityX
    this.engine.gravity.y = this.gravityY
    return h('span',
      { class: this._class, style:{ position: 'relative' }, },
      [
        h('div', {
          style:{ position: 'absolute', left: 0, top: 0 },
          ref: 'overlay',
        }),
        ...this.$slots.default,
      ])
  },
  data() {
    const world = this
    const views = [], links = new Map
    this.engine = Matter.Engine.create({
      enableSleeping: true,
    })
    this.runner = Matter.Runner.create()
    this.worldViews = views
    this.links = links
    this.updateViews = function() {
      const transforms = views.map(view => {
        // Rotate, then translate by in-world position, plus the static-layout movement since creation.
        const el = view.$el, body = view.body
        if (body.isSleeping) return
        const x1 = body.position.x, y1 = body.position.y
        const firstPos = view.initialPos
        const curPos = _getStaticElemPos(el, world.$el)
        const x2 = x1 - firstPos.x
        const y2 = y1 - firstPos.y
        return `translate(${x2 | 0}px,${y2 | 0}px) rotate(${body.angle}rad)`
      })
      for (let i = 0; i < views.length; ++i)
        if (transforms[i]) views[i].$el.style.transform = transforms[i]
      // Rotate+scale constraint images.
      links.forEach((constraint, el) => {
        const pA = Matter.Constraint.pointAWorld(constraint)
        const pB = Matter.Constraint.pointBWorld(constraint)
        const dx = pB.x - pA.x
        const dy = pB.y - pA.y
        const distance = Math.hypot(dy, dx)
        const angle = Math.atan2(dy, dx)
        el.style.position = 'absolute'
        el.style.transformOrigin = '0 0'
        el.style.transform = ` translate(${pA.x | 0}px,${pA.y | 0}px) rotate(${angle}rad) scale(${distance/100},1)`
      })
    }
    this.unboundConstraints = Object.create(null)
    return {}
  },
  async mounted() {
    await new Promise(requestAnimationFrame)
    Matter.Runner.start(this.runner, this.engine)
    Matter.Events.on(this.runner, 'afterUpdate', this.updateViews)

    // Add rects around the edges.
    if (this.bounded) {
      const extra = 500
      const rect = this.$el.getBoundingClientRect()
      const w = rect.width, h = rect.height
      const comp = Matter.Composite, world = this.engine.world
      const r = (x,y,w,h,opt) => Matter.Bodies.rectangle(x+w/2,y+h/2,w,h,opt)
      const opt = { isStatic: true }
      comp.add(world, r(-extra, -extra, w + 2*extra, extra, opt))
      comp.add(world, r(-extra, h, w + 2*extra, extra, opt))
      comp.add(world, r(-extra, 0, extra, h, opt))
      comp.add(world, r(w, 0, extra, h, opt))
    }

    // Also react to transitions inside <obj>ects like they're moving physical parts.
    //   The assumed density is 1.
    const world = this
    const trackedElems = new Map
    function trackTransitions() {
      const mult = 1e-3
      for (let [el, last] of trackedElems) {
        const rect = el.getBoundingClientRect(), pRect = el.parentNode.getBoundingClientRect()
        const x = rect.x - pRect.x + rect.width/2
        const y = rect.y - pRect.y + rect.height/2
        const dx = x - last.x, dy = last.y
        const ddx = dx - last.dx, ddy = dy - last.dy
        const area = rect.width * rect.height
        const forceX = area * ddx * mult, forceY = area * ddy * mult
        Matter.Body.applyForce(last.obj.body, { x, y }, { x: forceX, y: forceY })
        last.x = x, last.y = y, last.dx = dx, last.dy = dy
      }
      if (trackedElems.size)
        requestAnimationFrame(trackTransitions)
    }
    this.$el.ontransitionstart = evt => {
      const el = evt.target
      if (evt.propertyName !== 'transform' || !(el instanceof Element)) return
      if (trackedElems.has(el)) return
      const obj = _getObjAtElem(el)
      if (!obj) return
      const rect = el.getBoundingClientRect(), pRect = el.parentNode.getBoundingClientRect()
      const wasEmpty = !trackedElems.size
      trackedElems.set(el, {
        x: rect.x - pRect.x + rect.width/2,
        y: rect.y - pRect.y + rect.height/2,
        dx: 0,
        dy: 0,
        obj,
      })
      if (wasEmpty)
        requestAnimationFrame(trackTransitions)
    }
    this.$el.ontransitionend = evt => {
      if (evt.propertyName !== 'transform' || !(evt.target instanceof Element)) return
      trackedElems.delete(evt.target)
    }

    // Also some mouse constraints.
    if (this.allowDragging) {
      const mouse = Matter.Mouse.create(this.$el)
      const mouseConstraint = Matter.MouseConstraint.create(this.engine, {
        mouse,
        constraint:{
          angularStiffness: 0,
        },
      })
      Matter.Composite.add(this.engine.world, mouseConstraint)
    }
  },
  beforeDestroy() {
    Matter.Events.off(this.runner, 'afterUpdate', this.updateViews)
    Matter.Runner.stop(this.runner)
    Matter.Engine.clear(this.engine)
  },
  provide() { return { world: this } },
})

Vue.component('obj', {
  props:{
    _class:{ type: String, default: 'block' },
    static:{ type: Boolean, default: false, },
    density:{ type: Number, default: 1, },
    restitution:{ type: Number, default: .5, },
    friction:{ type: Number, default: .8, },
    frictionAir:{ type: Number, default: .0003, },
    frictionStatic:{ type: Number, default: .5, },
  },
  render(h) {
    if (this.body)
      this.body.density = this.density,
      this.body.friction = this.friction,
      this.body.frictionAir = this.frictionAir,
      this.body.frictionStatic = this.frictionStatic,
      this.body.restitution = this.restitution,
      this.body.isStatic = this.static
    return h('span', { class:this._class }, this.$slots.default)
  },
  async mounted() {
    this.$el._vueObj = this
    await new Promise(requestAnimationFrame)
    this.body = Matter.Body.create({})
    this.initialPos = null
    const vec = Matter.Vector
    const vRect = this.$el.getBoundingClientRect()
    const w = vRect.width, h = vRect.height
    const pos = _getStaticElemPos(this.$el, this.world.$el)
    pos.x += w/2, pos.y += h/2
    // Create the body, with rounded corners if present (only non-percentage, equal for each corner).
    const style = getComputedStyle(this.$el)
    const vertices = []
    function vertex(x, y) {
      const last = vertices[vertices.length-1]
      if (!last || Math.abs(x - last.x) > 1e-4 || Math.abs(y - last.y) > 1e-4)
        vertices.push({ x, y })
    }
    function corner(prop, cx, cy, i, vertices = 4) {
      let rad = parseFloat(style[prop], 10) || 0
      const x = cx*w/2, y = cy*h/2
      if (rad) {
        rad = Math.min(rad, w/2 - 1e-4)
        rad = Math.min(rad, h/2 - 1e-4)
        const centerX = x - cx * rad, centerY = y - cy * rad
        for (let j = 0; j < vertices; ++j) {
          const dx = Math.cos((i + j / (vertices-1)) * Math.PI / 2)
          const dy = Math.sin((i + j / (vertices-1)) * Math.PI / 2)
          vertex(centerX + dx*rad, centerY + dy*rad)
        }
      } else vertex(x, y)
    }
    corner('borderTopLeftRadius', -1, -1, 2) // -W,-H+R and -W+R,-H
    corner('borderTopRightRadius', 1, -1, 3) // W-R,-H and W,-H+R
    corner('borderBottomRightRadius', 1, 1, 4) // W,H-R and W-R,H
    corner('borderBottomLeftRadius', -1, 1, 5) // -W+R,H and -W,H-R
    Matter.Body.set(this.body, {
      // See https://brm.io/matter-js/docs/classes/Body.html
      angle: 0,
      density: this.density,
      friction: this.friction,
      frictionAir: this.frictionAir,
      frictionStatic: this.frictionStatic,
      restitution: this.restitution,
      isStatic: this.static,
      position: vec.create(pos.x, pos.y),
      vertices,
    })
    Matter.Body.setStatic(this.body, this.static)
    Matter.Composite.add(this.world.engine.world, this.body)
    this.world.worldViews.push(this)
    this.initialPos = pos
  },
  beforeDestroy() {
    const arr = this.world.worldViews
    if (arr.indexOf(this) >= 0) arr.splice(arr.indexOf(this), 1)
    Matter.Composite.remove(this.world.engine.world, this.body)
  },
  inject: ['world'],
})
Vue.component('constraint', {
  props:{
    _class:{ type: String, default: '' },
    name:{ type: String, required: true },
    damping:{ type: Number, default: 0, },
    stiffness:{ type: Number, default: .1, },
  },
  render(h) {
    if (this.constraint)
      this.constraint.damping = this.damping, this.constraint.stiffness = stiffness
    return h('span', { class: this._class, style:{ width: '0px', height: '0px' } }, this.$slots.default)
  },
  async mounted() {
    if (this.constraint) return
    this.$el._vueConstraint = this
    await new Promise(requestAnimationFrame)
    await new Promise(requestAnimationFrame)
    const con = this.world.unboundConstraints
    this.inBody = _getObjAtElem(this.$el)
    if (con[this.name]) {
      const that = con[this.name];  delete con[this.name]
      this.other = that, that.other = this
      this.constraint = that.constraint = Matter.Constraint.create({
        bodyA: this.inBody ? this.inBody.body : undefined,
        bodyB: that.inBody ? that.inBody.body : undefined,
        pointA: this.inBody ? _getElemOffset(this.$el, this.inBody.$el) : _getStaticElemPos(this.$el, this.world.$el),
        pointB: that.inBody ? _getElemOffset(that.$el, that.inBody.$el) : _getStaticElemPos(that.$el, that.world.$el),
        damping: this.damping,
        stiffness: this.stiffness,
      })
      const el = document.createElement('div')
      el.className = 'dot'
      this.link = that.link = this.world.$refs.overlay.appendChild(el)
      this.world.links.set(this.link, this.constraint)
      Matter.Composite.add(this.world.engine.world, this.constraint)
    } else
      con[this.name] = this
  },
  beforeDestroy() {
    if (this.constraint) {
      Matter.Composite.remove(this.world.engine.world, this.constraint)
      if (this.other) {
        const that = this.other
        that.other = undefined, that.constraint = undefined
      }
      if (this.link)
        this.link.remove(),
        this.world.$refs.overlay.removeChild(this.link),
        this.link = that.link = undefined
    }
  },
  inject: ['world'],
})
function _getObjAtElem(el) {
  while (el && el._vueObj === undefined) el = el.parentNode
  return el && el._vueObj
}
function _getStaticElemPos(el, until = null) {
  let x = 0, y = 0, n = 0
  while (!until ? el !== until : (el && el !== until && until.contains(el))) {
    const style = getComputedStyle(el)
    x += el.offsetLeft - parseFloat(style.marginLeft)
    y += el.offsetTop - parseFloat(style.marginTop)
    el = el.offsetParent
    ++n
  }
  if (el !== until) x -= el.offsetLeft, y -= el.offsetTop
  return { x, y }
}
function _getElemOffset(from, to) {
  const r1 = from.getBoundingClientRect(), r2 = to.getBoundingClientRect()
  const x = r2.x - r1.x + (r2.width - r1.width) / 2
  const y = r2.y - r1.y + (r2.height - r1.height) / 2
  return { x, y }
}
  </script>

  <script>
    Vue.component('block', {
      render(h) { return h('span', { class:'block' }, [this.$slots.default || ' ']) },
    })
    Vue.component('animated-text', {
      props:['value'],
      render(h) {
        const occured = {}
        return h('transition-group',
          { props: {name:'fade'}, },
          (''+this.value).split('').map(
            (ch, i) => h('block', { key:ch + (occured[ch] = (occured[ch] || 0) + 1) }, ch)))
      },
    })
    window.app = new Vue({
      el: '#app',
      data:{
        message: 'Hello Vue!',
        count: 0,
        text: '',
        items: [1,2,3,4],
      },
      methods:{
        shuffle(a) {
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1))
            var tmp = a[i]
            Vue.set(a, i, a[j])
            Vue.set(a, j, tmp)
          }
        },
      },
    })
  </script>

  <style>
    .block {
      display: inline-block;
      white-space: pre-wrap;
    }
    .fade-enter-active, .fade-leave-active, .fade-move {
      transition: opacity .2s, transform .2s;
    }
    .fade-enter {
      opacity: 0;
      transform: rotate(-200deg);
    }
    .fade-leave-active {
      position: absolute;
      opacity: 0;
      transform: rotate(100deg);
    }
  </style>
</body>
</html>