{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA,sBAAsB,UAAU;AAChC,wBAAwB,QAAQ;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA,sBAAsB,YAAY;AAClC;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA,2CAA2C,mBAAmB;AAC9D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,eAAe,2BAA2B;AAC1C,eAAe,2BAA2B;AAC1C,cAAc,8BAA8B;AAC5C,oBAAoB,8BAA8B;AAClD,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ,4BAA4B,sBAAsB,GAAG;AAC7D;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO,KAAK,OAAO,aAAa,WAAW;AACvE,OAAO;AACP,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS,KAAK,SAAS,aAAa,MAAM,aAAa,aAAa;AAC/G,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,IAAI,sBAAsB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,cAAc,SAAS,eAAe;AACtC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,aAAa,gCAAgC;AAC7C,cAAc,2BAA2B;AACzC,kBAAkB,4BAA4B;AAC9C,eAAe,4BAA4B;AAC3C,kBAAkB,+BAA+B;AACjD,qBAAqB,4BAA4B;AACjD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,GAAG;AACH;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC,WAAW,8BAA8B;AACzC,cAAc,6BAA6B;AAC3C,gBAAgB,4BAA4B;AAC5C,GAAG;AACH;AACA;AACA;AACA,uBAAuB,4BAA4B,+BAA+B;AAClF,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;;;;;UCpVA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNqB;AACD;AACpB;AACA;AACA;AACA,cAAc,mBAAmB,eAAe,iCAAiC;AACjF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ,YAAY,GAAG;AAC/B;AACA,gCAAgC,iDAAiD;AACjF,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wB","sources":["webpack:///./canvas.js","webpack:///./physics.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./index.js"],"sourcesContent":["const N = 8\r\ndraw(newCtx(500, 300), N, fullLayers(N, 1))\r\ndraw(newCtx(500, 300), N, hyperLayers(N, 2, 1))\r\n\r\n\r\nfunction newCtx(w, h) {\r\n  const ctx = document.body.appendChild(document.createElement('canvas')).getContext('2d')\r\n  ctx.canvas.width = w, ctx.canvas.height = h\r\n  return ctx\r\n}\r\n\r\nfunction fullLayers(N = 16, layers = 1) {\r\n  const res = []\r\n  for (let L = 0; L < layers; ++L)\r\n    res.push(function fullLayer(connect, from, to) {\r\n      for (let i = 0; i < from; ++i)\r\n        for (let j = 0; j < to; ++j)\r\n          connect(i, j)\r\n    })\r\n  return res\r\n}\r\n\r\nfunction hyperLayers(N = 16, n = 2, layers = 1) {\r\n  const res = []\r\n  for (let L = 0; L < layers; ++L) {\r\n    const subs = Math.ceil(Math.log(N) / Math.log(n) - 1e-8)\r\n    for (let sub = 0; sub < subs; ++sub)\r\n      res.push(function logLayer(connect, from, to) {\r\n        const stride = n ** sub\r\n        for (let to = 0; to < N; ++to) {\r\n          let batch_id = to % stride + (to / (n*stride) | 0) * n*stride\r\n          for (let i = 0, from = batch_id; i < n && from < N; ++i, from += stride)\r\n            connect(from, to)\r\n        }\r\n      })\r\n  }\r\n  return res.reverse()\r\n}\r\n\r\nfunction draw(ctx, n = 16, layers = [], radius = 4) {\r\n  const lineW = 1\r\n  const w = ctx.canvas.width - 2*(radius+lineW), h = ctx.canvas.height - 2*(radius+lineW)\r\n  const offsetX = radius+lineW, offsetY = radius+lineW\r\n  ctx.fillStyle = 'lightgray', ctx.strokeStyle = 'gray', ctx.lineWidth = lineW\r\n  let prevProgress = 0, nextProgress = 0\r\n  for (let L = 0; L <= layers.length; ++L) {\r\n    prevProgress = L / layers.length, nextProgress = (L+1) / layers.length\r\n    // Connect layers as they define.\r\n    if (L < layers.length)\r\n      layers[L](connect, n, n)\r\n  }\r\n  for (let L = 0; L <= layers.length; ++L) {\r\n    prevProgress = L / layers.length, nextProgress = (L+1) / layers.length\r\n    // Draw circles.\r\n    for (let j = 0; j < n; ++j) {\r\n      const x = offsetX + prevProgress * w, y = offsetY + j / (n-1 || 1) * h\r\n      ctx.beginPath()\r\n      ctx.arc(x, y, radius, 0, 2*Math.PI)\r\n      ctx.fill()\r\n      ctx.stroke()\r\n    }\r\n  }\r\n  return ctx\r\n  function connect(from, to) {\r\n    const fromX = offsetX + prevProgress * w, fromY = offsetY + from / (n-1 || 1) * h\r\n    const toX = offsetX + nextProgress * w, toY = offsetY + to / (n-1 || 1) * h\r\n    ctx.beginPath()\r\n    ctx.moveTo(fromX, fromY)\r\n    ctx.lineTo(toX, toY)\r\n    ctx.stroke()\r\n  }\r\n}\r\n","\r\n\r\n// Vue-integrated physics.\r\nVue.component('world', {\r\n  props:{\r\n    _class:{ type: String, default: 'block' },\r\n    gravityX:{ type: Number, default: 0, },\r\n    gravityY:{ type: Number, default: 1, },\r\n    bounded:{ type: Boolean, default: true },\r\n    allowDragging:{ type: Boolean, default: true },\r\n  },\r\n  render(h) {\r\n    this.engine.gravity.x = this.gravityX\r\n    this.engine.gravity.y = this.gravityY\r\n    return h('span',\r\n      { class: this._class, style:{ position: 'relative' }, },\r\n      [\r\n        h('div', {\r\n          style:{ position: 'absolute', left: 0, top: 0 },\r\n          ref: 'overlay',\r\n        }),\r\n        ...this.$slots.default,\r\n      ])\r\n  },\r\n  data() {\r\n    const views = [], links = new Map\r\n    this.engine = Matter.Engine.create({\r\n      enableSleeping: true,\r\n    })\r\n    this.runner = Matter.Runner.create()\r\n    this.worldViews = views\r\n    this.links = links\r\n    this.updateViews = function() {\r\n      const transforms = views.map(view => {\r\n        // Rotate, then translate by in-world position, plus the static-layout movement since creation.\r\n        const body = view.body\r\n        if (body.isSleeping) return\r\n        const x1 = body.position.x, y1 = body.position.y\r\n        const firstPos = view.initialPos\r\n        const x2 = x1 - firstPos.x\r\n        const y2 = y1 - firstPos.y\r\n        return `translate(${x2 | 0}px,${y2 | 0}px) rotate(${body.angle}rad)`\r\n      })\r\n      for (let i = 0; i < views.length; ++i)\r\n        if (transforms[i]) views[i].$el.style.transform = transforms[i]\r\n      // Rotate+scale constraint images.\r\n      links.forEach((constraint, el) => {\r\n        const pA = Matter.Constraint.pointAWorld(constraint)\r\n        const pB = Matter.Constraint.pointBWorld(constraint)\r\n        const dx = pB.x - pA.x\r\n        const dy = pB.y - pA.y\r\n        const distance = Math.hypot(dy, dx)\r\n        const angle = Math.atan2(dy, dx)\r\n        el.style.position = 'absolute'\r\n        el.style.transformOrigin = '0 0'\r\n        el.style.transform = ` translate(${pA.x | 0}px,${pA.y | 0}px) rotate(${angle}rad) scale(${distance/100},1)`\r\n      })\r\n    }\r\n    this.unboundConstraints = Object.create(null)\r\n    this.edges = []\r\n    return {}\r\n  },\r\n  async mounted() {\r\n    await new Promise(requestAnimationFrame)\r\n    Matter.Runner.start(this.runner, this.engine)\r\n    Matter.Events.on(this.runner, 'afterUpdate', this.updateViews)\r\n\r\n    // Add rects around the edges.\r\n    _updateWorldBounds(this, this.bounded)\r\n\r\n    // Also react to transitions inside <obj>ects like they're moving physical parts.\r\n    //   The assumed density is 1.\r\n    const trackedElems = new Map\r\n    function trackTransitions() {\r\n      const mult = 1e-3\r\n      for (let [el, last] of trackedElems) {\r\n        const rect = el.getBoundingClientRect(), pRect = el.parentNode.getBoundingClientRect()\r\n        const x = rect.x - pRect.x + rect.width/2\r\n        const y = rect.y - pRect.y + rect.height/2\r\n        const dx = x - last.x, dy = last.y\r\n        const ddx = dx - last.dx, ddy = dy - last.dy\r\n        const area = rect.width * rect.height\r\n        const forceX = area * ddx * mult, forceY = area * ddy * mult\r\n        Matter.Body.applyForce(last.obj.body, { x, y }, { x: forceX, y: forceY })\r\n        last.x = x, last.y = y, last.dx = dx, last.dy = dy\r\n      }\r\n      if (trackedElems.size)\r\n        requestAnimationFrame(trackTransitions)\r\n    }\r\n    this.$el.ontransitionstart = evt => {\r\n      const el = evt.target\r\n      if (evt.propertyName !== 'transform' || !(el instanceof Element)) return\r\n      if (trackedElems.has(el)) return\r\n      const obj = _getObjAtElem(el)\r\n      if (!obj) return\r\n      const rect = el.getBoundingClientRect(), pRect = el.parentNode.getBoundingClientRect()\r\n      const wasEmpty = !trackedElems.size\r\n      trackedElems.set(el, {\r\n        x: rect.x - pRect.x + rect.width/2,\r\n        y: rect.y - pRect.y + rect.height/2,\r\n        dx: 0,\r\n        dy: 0,\r\n        obj,\r\n      })\r\n      if (wasEmpty)\r\n        requestAnimationFrame(trackTransitions)\r\n    }\r\n    this.$el.ontransitionend = evt => {\r\n      if (evt.propertyName !== 'transform' || !(evt.target instanceof Element)) return\r\n      trackedElems.delete(evt.target)\r\n    }\r\n\r\n    // Also some mouse constraints.\r\n    if (this.allowDragging) {\r\n      const mouse = Matter.Mouse.create(this.$el)\r\n      // What the fuck, Matter.js. Why prevent scrolling?\r\n      //   https://github.com/liabru/matter-js/blob/master/src/core/Mouse.js\r\n      this.$el.removeEventListener('mousewheel', mouse.mousewheel)\r\n      this.$el.removeEventListener('DOMMouseScroll', mouse.mousewheel)\r\n      const mouseConstraint = Matter.MouseConstraint.create(this.engine, {\r\n        mouse,\r\n        constraint:{\r\n          damping: .9,\r\n          stiffness: .05,\r\n        },\r\n      })\r\n      Matter.Composite.add(this.engine.world, mouseConstraint)\r\n    }\r\n\r\n    // On resize, update the bounding boxes of all objects.\r\n    this.resizeObs = new ResizeObserver(() => {\r\n      _updateWorldBounds(this, this.bounded)\r\n      this.worldViews.forEach(_updatePhysObject) // TODO: Why does this result in position mismatch?\r\n    })\r\n    this.resizeObs.observe(this.$el)\r\n  },\r\n  beforeDestroy() {\r\n    this.resizeObs.unobserve(this.$el)\r\n    Matter.Events.off(this.runner, 'afterUpdate', this.updateViews)\r\n    Matter.Runner.stop(this.runner)\r\n    Matter.Engine.clear(this.engine)\r\n  },\r\n  provide() { return { world: this } },\r\n})\r\n\r\n\r\n\r\nfunction _updateWorldBounds(obj, bounded) {\r\n  // Creates 4 rects.\r\n  const comp = Matter.Composite, world = obj.engine.world\r\n  obj.edges.forEach(e => comp.remove(world, e))\r\n  obj.edges.length = 0\r\n  if (bounded) {\r\n    const extra = 500\r\n    const w = obj.$el.offsetWidth, h = obj.$el.offsetHeight\r\n    const r = (x,y,w,h,opt) => Matter.Bodies.rectangle(x+w/2,y+h/2,w,h,opt)\r\n    const opt = { isStatic: true }\r\n    obj.edges.push(\r\n      r(-extra, -extra, w + 2*extra, extra, opt),\r\n      r(-extra, h, w + 2*extra, extra, opt),\r\n      r(-extra, 0, extra, h, opt),\r\n      r(w, 0, extra, h, opt),\r\n    )\r\n    obj.edges.forEach(e => comp.add(world, e))\r\n  }\r\n}\r\n\r\n\r\n\r\nVue.component('obj', {\r\n  props:{\r\n    _class:{ type: String, default: 'block' },\r\n    static:{ type: Boolean, default: false, },\r\n    density:{ type: Number, default: 1, },\r\n    restitution:{ type: Number, default: .3, },\r\n    friction:{ type: Number, default: .7, },\r\n    frictionAir:{ type: Number, default: .0003, },\r\n    frictionStatic:{ type: Number, default: .9, },\r\n  },\r\n  render(h) {\r\n    if (this.body) {\r\n      this.body.density = this.density\r\n      this.body.friction = this.friction\r\n      this.body.frictionAir = this.frictionAir\r\n      this.body.frictionStatic = this.frictionStatic\r\n      this.body.restitution = this.restitution\r\n      this.body.isStatic = this.static\r\n    }\r\n    return h('span', { class:this._class }, this.$slots.default)\r\n  },\r\n  async mounted() {\r\n    this.$el._vueObj = this\r\n    await new Promise(requestAnimationFrame)\r\n    this.body = Matter.Body.create({})\r\n    this.initialPos = null\r\n    const pos = _getStaticElemPos(this.$el, this.world.$el)\r\n    const w = this.$el.offsetWidth, h = this.$el.offsetHeight\r\n    pos.x += w/2, pos.y += h/2\r\n    this.initialPos = pos\r\n    Matter.Body.set(this.body, {\r\n      angle: 0,\r\n      position: Matter.Vector.create(pos.x, pos.y),\r\n    })\r\n    _updatePhysObject(this)\r\n    Matter.Composite.add(this.world.engine.world, this.body)\r\n    this.world.worldViews.push(this)\r\n  },\r\n  beforeDestroy() {\r\n    const arr = this.world.worldViews\r\n    if (arr.indexOf(this) >= 0) arr.splice(arr.indexOf(this), 1)\r\n    Matter.Composite.remove(this.world.engine.world, this.body)\r\n  },\r\n  inject: ['world'],\r\n})\r\n\r\n\r\n\r\nfunction _updatePhysObject(obj) {\r\n  const el = obj.$el, body = obj.body\r\n  // Create the body, with rounded corners if present (only non-percentage, equal for each corner).\r\n  const w = el.offsetWidth, h = el.offsetHeight\r\n  const style = getComputedStyle(el)\r\n  const vertices = []\r\n  const angle = body.angle || 0\r\n  function vertex(x, y) {\r\n    const last = vertices[vertices.length-1]\r\n    // Ah yes, translate vertices automatically, but don't rotate them. Quality physics engine.\r\n    ;[x, y] = [x * Math.cos(angle) - y * Math.sin(angle), x * Math.sin(angle) + y * Math.cos(angle)]\r\n    if (!last || Math.abs(x - last.x) > 1e-4 || Math.abs(y - last.y) > 1e-4)\r\n      vertices.push({ x, y })\r\n  }\r\n  function corner(prop, cx, cy, i, vertices = 16) {\r\n    let rad = parseFloat(style[prop], 10) || 0\r\n    const x = cx*w/2, y = cy*h/2\r\n    if (rad) {\r\n      rad = Math.min(rad, w/2 - 1e-4)\r\n      rad = Math.min(rad, h/2 - 1e-4)\r\n      const centerX = x - cx * rad, centerY = y - cy * rad\r\n      for (let j = 0; j < vertices; ++j) {\r\n        const dx = Math.cos((i + j / (vertices-1)) * Math.PI / 2)\r\n        const dy = Math.sin((i + j / (vertices-1)) * Math.PI / 2)\r\n        vertex(centerX + dx*rad, centerY + dy*rad)\r\n      }\r\n    } else vertex(x, y)\r\n  }\r\n  corner('borderTopLeftRadius', -1, -1, 2) // -W,-H+R and -W+R,-H\r\n  corner('borderTopRightRadius', 1, -1, 3) // W-R,-H and W,-H+R\r\n  corner('borderBottomRightRadius', 1, 1, 4) // W,H-R and W-R,H\r\n  corner('borderBottomLeftRadius', -1, 1, 5) // -W+R,H and -W,H-R\r\n  Matter.Body.set(body, {\r\n    // See https://brm.io/matter-js/docs/classes/Body.html\r\n    density: obj.density,\r\n    friction: obj.friction,\r\n    frictionAir: obj.frictionAir,\r\n    frictionStatic: obj.frictionStatic,\r\n    restitution: obj.restitution,\r\n    isStatic: obj.static,\r\n  })\r\n  Matter.Body.setVertices(body, vertices)\r\n}\r\n\r\n\r\n\r\nVue.component('constraint', {\r\n  props:{\r\n    _class:{ type: String, default: '' },\r\n    name:{ type: String, required: true },\r\n    damping:{ type: Number, default: .05, },\r\n    stiffness:{ type: Number, default: .5, },\r\n  },\r\n  render(h) {\r\n    if (this.constraint)\r\n      this.constraint.damping = this.damping, this.constraint.stiffness = stiffness\r\n    return h('span', { class: this._class, style:{ width: '0px', height: '0px' } }, this.$slots.default)\r\n  },\r\n  async mounted() {\r\n    if (this.constraint) return\r\n    this.$el._vueConstraint = this\r\n    await new Promise(requestAnimationFrame)\r\n    await new Promise(requestAnimationFrame)\r\n    const con = this.world.unboundConstraints\r\n    this.inBody = _getObjAtElem(this.$el)\r\n    if (con[this.name]) {\r\n      const that = con[this.name];  delete con[this.name]\r\n      this.other = that, that.other = this\r\n      this.constraint = that.constraint = Matter.Constraint.create({\r\n        bodyA: this.inBody ? this.inBody.body : undefined,\r\n        bodyB: that.inBody ? that.inBody.body : undefined,\r\n        pointA: this.inBody ? _getElemOffset(this.$el, this.inBody.$el) : _getStaticElemPos(this.$el, this.world.$el),\r\n        pointB: that.inBody ? _getElemOffset(that.$el, that.inBody.$el) : _getStaticElemPos(that.$el, that.world.$el),\r\n        damping: this.damping,\r\n        stiffness: this.stiffness,\r\n      })\r\n      const el = document.createElement('div')\r\n      el.className = 'dot'\r\n      this.link = that.link = this.world.$refs.overlay.appendChild(el)\r\n      this.world.links.set(this.link, this.constraint)\r\n      Matter.Composite.add(this.world.engine.world, this.constraint)\r\n    } else\r\n      con[this.name] = this\r\n  },\r\n  beforeDestroy() {\r\n    if (this.constraint) {\r\n      Matter.Composite.remove(this.world.engine.world, this.constraint)\r\n      if (this.other) {\r\n        const that = this.other\r\n        that.other = undefined, that.constraint = undefined\r\n      }\r\n      if (this.link)\r\n        this.link.remove(),\r\n        this.world.$refs.overlay.removeChild(this.link),\r\n        this.link = that.link = undefined\r\n    }\r\n  },\r\n  inject: ['world'],\r\n})\r\n\r\n\r\n\r\nfunction _getObjAtElem(el) {\r\n  while (el && el._vueObj === undefined) el = el.parentNode\r\n  return el && el._vueObj\r\n}\r\nfunction _getStaticElemPos(el, until = null) {\r\n  let x = 0, y = 0, n = 0\r\n  while (!until ? el !== until : (el && el !== until && until.contains(el))) {\r\n    const style = getComputedStyle(el)\r\n    x += el.offsetLeft - parseFloat(style.marginLeft)\r\n    y += el.offsetTop - parseFloat(style.marginTop)\r\n    el = el.offsetParent\r\n    ++n\r\n  }\r\n  if (el !== until) x -= el.offsetLeft, y -= el.offsetTop\r\n  return { x, y }\r\n}\r\nfunction _getElemOffset(from, to) {\r\n  const r1 = from.getBoundingClientRect(), r2 = to.getBoundingClientRect()\r\n  const x = r2.x - r1.x + (r2.width - r1.width) / 2\r\n  const y = r2.y - r1.y + (r2.height - r1.height) / 2\r\n  return { x, y }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './physics.js'\r\nimport './canvas.js'\r\n\r\n\r\nVue.component('block', {\r\n  render(h) { return h('span', { class:'block' }, [this.$slots.default || ' ']) },\r\n})\r\nVue.component('animated-text', {\r\n  props:['value'],\r\n  render(h) {\r\n    const occured = {}\r\n    return h('transition-group',\r\n      { props: {name:'fade'}, },\r\n      (''+this.value).split('').map(\r\n        (ch, i) => h('block', { key:ch + (occured[ch] = (occured[ch] || 0) + 1) }, ch)))\r\n  },\r\n})\r\nwindow.app = new Vue({\r\n  el: '#app',\r\n  data:{\r\n    title: 'software engineer',\r\n    business: 'builds stuff',\r\n  },\r\n})\r\n\r\n\r\n\r\n// Intermittently, update the description randomly.\r\nfunction pick(a) { return a[Math.random() * a.length | 0] }\r\nsetTimeout(function f() {\r\n  // TODO: More descriptive & concrete things.\r\n  app.title = pick([\r\n    'software engineer',\r\n    'developer',\r\n    'person',\r\n  ])\r\n  setTimeout(f, Math.random() * 20000)\r\n}, Math.random() * 20000)\r\nsetTimeout(function f() {\r\n  // TODO: More descriptive & concrete things.\r\n  app.business = pick([\r\n    'builds stuff',\r\n    'delivers code',\r\n    'creates experiences',\r\n  ])\r\n  setTimeout(f, Math.random() * 20000)\r\n}, Math.random() * 20000)"],"names":[],"sourceRoot":""}